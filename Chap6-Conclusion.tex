\chapter{Conclusion}
\label{chap:6_Conclusion}

    In this chapter we discuss the results and future work.
    
    \section{Results Discussion}

    In this work, we present a \acl{GNC} (\ac{GNC}) system for autonomous \aclp{USV} (\acp{USV}). Due to the need for vessels that navigate in the water surface to respect \acl{COLREGS} (\ac{COLREGS}), we apply a method of path planning to our system to avoid violating \ac{COLREGS} when a vessel using our system encounters another.

    The system we develop is composed of navigation, control, and guidance modules. The navigation system is responsible for perceiving the state of the surrounding environment and the vessel's state itself. The control system can modify the state of the \ac{USV} and move it. The guidance system defines a path to achieve a goal using the information collected by the navigation system considering the state of the environment and the vessel itself.
    
    Our main contribution was the development and integration of these modules and the adaptation of a technique presented in the literature to make the behavior of a vessel guided by our system respect the \ac{COLREGS}. Our system can react following the \ac{COLREGS} when it finds only one approaching vessel. When finding multiple vessels, our system can generate routes to avoid collision, but the \ac{COLREGS} compliance capacity has not been guaranteed. Another limitation is related to our system, considering that the approaching vessel is of the same type as ours since different categories of vessels imply a change in the \ac{COLREGS} interpretation.
    
    Our solution uses A* to find a path that leads towards the location goal. When a vessel approaches ours, our local planning module reacts and generates \ac{COLREGS}-compliant routes. To generate \ac{COLREGS} compliant routes, we have adapted the solution presented by Agrawal~\etal~\cite{Agrawal2015COLREGS} in our system. When our system detects another vessel in its proximity, it creates a virtual obstacle that restricts the search space of our local planner, excluding positions that would violate \ac{COLREGS}. Thus the local planner is forced to choose a \ac{COLREGS}-compliant route.

    We evaluate the performance of our system regarding the main scenarios of encounter described in \ac{COLREGS}, they are head-on, crossing from the right, crossing from the left, and overtaking. We collected the maximum and average computational time for the execution of our \aclp{ATC} (\ac{ATC}) A* method in each cycle. For all simulated scenarios, our system was able to avoid collision and follow \ac{COLREGS} even with a wind intensity of 2 m/s.

    Our \ac{ATC} A* method has been effective for \ac{COLREGS}-compliance collision avoidance in the scenarios we simulated. Regarding performance, the computational cost is mainly related to our A* implementation. Our A* implementation has several conversions operations between the global and local scope. These operations consist of operations that evaluate the value of each cell in an mxm grid, where m is equal to 100.

    The creation of virtual obstacles with \ac{ATC}, creates indirectly and intermittently an increase in computational time, due to the restriction in the search space. The impact of creating obstacles with \ac{ATC} is low compared to the total cost since the implementation of \ac{ATC} for creating virtual obstacles consists of filling in the values on the local cost map in a wxl area, where w is the local width of our vessel and l  is the distance between the approaching vessel and the corresponding edge of the local cost map. In the worst case, l is 99, since the side of the cost map location is 100, and the \ac{AV} must occupy at least one position of the cost map location. Intermittent behavior occurs because, when an obstacle is created and occupies the same position as the local goal, the local planner extinguishes the entire search area and look backward in the global plan for a valid position goal in the local cost maps.
    
    \section{Future Work}
    
    The main improvements are related to the reduction of computational time, an increase in the maximum speed of the vessel, and a greater variety in possible encounters. Regarding computational time, it is necessary to investigate our implementation of A* to find out if there is any possible improvement that impacts on the total time of execution of our local planner. Another major limitation related to our local planner is the reduced ability to generate velocity commands that allow \ac{USV} to navigate with more than 0.4 m/s. The simulated \ac{USV} model we used in our tests can navigate up to 1.8 m/s. This improvement requires investigation to understand better where the speed restriction is.
    
    Regarding variety in the encounter, our system has the potential to be simulated in an environment with multiple boats. It is necessary to study ways to apply our method based on the creation of virtual obstacles for situations where simultaneous encounters between multiple vessels occur. Perhaps a necessary change is the removal of lethality from virtual obstacles. Currently, the virtual obstacles created are considered impassable by the local planner. In multiple encounters, there is a potential increase in space restriction, where it is not possible to navigate. Therefore, high-cost virtual obstacles could be created for the planner but with the possibility of transposition if it is the only choice to avoid collision.
    
    Related to the encounters variety, we should study ways to consider different categories of vessels found and take this into account when creating virtual obstacles. For example, where our vessel is power-driven and finds a sailing vessel to its left, instead of keeping its course and waiting for the vessel on left to avoid collision, our vessel assumes the responsibility of evading the collision.
    
    Another possible improvement would be to add a ray of cost inflation around the virtual obstacles created. This could prevent the A* method from exploring locations that are neighbors of virtual obstacles, possibly decreasing the computational cost. In the tests performed, the method explored large areas close to the virtual obstacles, due to the heuristic behavior of the algorithm. However, these obstacles could not be overcome, so these nodes were explored but did not lead to the final trajectory.
    
     Regarding real-world tests, we could try to bound the maximum computational time reducing conversions from the local and global planners. So, we could evaluate the performance of our system when running in the embedded computers we have in the vessels of our laboratory. For  real-world tests would be necessary to study how to adequate each of the modules of our system to the hardware available in our vessel.
    
    
%AMA outras coisas q vou te pedir p incluir na distribuicao:  -comments c doxygen style. -script que instala o simulador, aplica todas as depedendencias, e aplica o teu pacote. - distribuicao clean (branches antigos removidos, remover codigo morto, colocar muito comentario (ingles, obvio), revisar se tem variaveis ou funcoes em portugues e renomear, tag da versao estavel) - todos codigos c um cabecalho legal e explicativo - quais sao os parametros q o user pode alterar ? qual eh o impacto de cada parametro ? - melhorar muito o readme principal.- me dar acesso ao https://github.com/Unmanned-Surface-Vehicle. referenciar o lab, a universidade , e a tua tese no readme. verias coisas pequenas q precisam ser melhroadas para q o trbalho nao morra ao final da tua tese.
%DJ: Entendi